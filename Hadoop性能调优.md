### 概述
该篇文章谈一谈Hadoop的性能调优，有哪些调优点，怎么去考虑。
### 1.存储格式压缩格式
对于存储格式压缩格式可以说是大数据场景下的很重要的一个调优点，压缩格式有哪些呢？最基本的TextFile(文本形式的行式存储)，SequenceFile（二进制形式的行式存储），RCfFile（先行后列）基于RCFile优化后的ORCFile（先行后列），Rarquet（先行后列）。选择合适的存储格式。

压缩的话，也是有好多种，并且他们具有不同的特点，Bzip2,gzip,lzo,lz4，snappy,default;了解他们的压缩比，以及能否分片的特点有助于选择合适的压缩方式。

对于存储格式和压缩格式的文章在本人博客中进行了详细的解答（<a href="https://blog.csdn.net/yu0_zhang0">博客地址</a>），这里就不说了，后面对于Hive的优化中也会说到。
### 2.设置Combiner
MapReduce计算过程我们知道Shuffe是非常影响性能的，对于一大批MapReduce程序，在不影响最终输出结果的情况下可以设置一个Combiner（比如累加，最大值等。Combiner的使用一定得慎重，如果用好，它对job执行效率有帮助，反之会影响reduce的最终结果。）,Combiner又称作map端的reduce,那么对于提高作业性能是十分有帮助的。Combiner可减少Map Task中间输出的结果，从而减少各个Reduce Task的远程拷贝数据量，最终表现为Map Task和Reduce Task执行时间缩短。

### 3.启动推测执行机制
推测执行是Hadoop对“拖后腿”的任务的一种优化机制，当一个作业的某些任务运行速度明显慢于同作业的其他任务时，Hadoop会在另一个节点上为“慢任务”启动一个备份任务，这样两个任务同时处理一份数据，而Hadoop最终会将优先完成的那个任务的结果作为最终结果，并将另一个任务杀掉。

### 4.设置失败容忍度
Hadoop运行设置任务级别和作业级别的失败容忍度。作业级别的失败容忍度是指Hadoop允许每个作业有一定比例的任务运行失败，这部分任务对应的输入数据将被忽略；
任务级别的失败容忍度是指Hadoop允许任务失败后再在另外节点上尝试运行，如果一个任务经过若干次尝试运行后仍然运行失败，那么Hadoop才会最终认为该任务运行失败。用户应该根据应用程序的特点设置合理的失败容忍度，以尽快让作业运行完成和避免没必要的资源浪费。
### 5.适当打开JVM重用功能
为了实现任务隔离，Hadoop将每个任务放到一个单独的JVM中执行，而对于执行时间较短的任务，JVM启动和关闭的时间将占用很大比例时间，为此，用户可以启用JVM重用功能，这样一个JVM可连续启动多个同类型的任务。

### 6.合理使用DistributedCache
一般情况下，得到外部文件有两种方法：一种是外部文件与应用程序jar包一起放到客户端，当提交作业时由客户端上传到HDFS的一个目录下，然后通过Distributed Cache分发到各个节点上；另一种方法是事先将外部文件直接放到HDFS上，从效率上讲，第二种方法更高效。第二种方法不仅节省了客户端上传文件的时间，还隐含着告诉DistributedCache:"请将文件下载到各个节点的pubic级别共享目录中”，这样，后续所有的作业可重用已经下载好的文件，不必重复下载。
### 7.提高作业优先级
所有Hadoop作业调度器进行任务调度时均会考虑作业优先级这一因素。作业的优先级越高，它能够获取的资源（slot数目)也越多。Hadoop提供了5种作业优先级，分别为VERY_HIGH、 HIGH、 NORMAL、 LOW、 VERY_LOW。</br>
注：在生产环境中，管理员已经按照作业重要程度对作业进行了分级，不同重要程度的作业允许配置的优先级不同，用户可以擅自进行调整。
### 任务级别参数调优
hadoop任务级别参数调优分两个方面: Map Task和Reduce Task。这方面的调优也很重要，在后面的Hive中还会涉及到。
1. Map Task调优
map 任务执行会产生中间数据,但这些中间结果并没有直接IO到磁盘上,而是先存储在缓存(buffer)中,并在缓存中进行一些预排序来优化整个map的性能,存储map中间数据的缓存默认大小为100M，由io.sort.mb 参数指定。这个大小可以根据需要调整。当map任务产生了非常大的中间数据时可以适当调大该参数,使缓存能容纳更多的map中间数据，而不至于大频率的IO磁盘,当系统性能的瓶颈在磁盘IO的速度上,可以适当的调大此参数来减少频繁的IO带来的性能障碍。

由于map任务运行时中间结果首先存储在缓存中,默认当缓存的使用量达到80%(或0.8)的时候就开始写入磁盘,这个过程叫做spill(也叫溢出),进行spill的缓存大小可以通过io.sort.spill.percent 参数调整，这个参数可以影响spill的频率。进而可以影响IO的频率。

当map任务计算成功完成之后，如果map任务有输出，则会产生多个spill。接下来map必须将些spill进行合并,这个过程叫做merge, merge过程是并行处理spill的,每次并行多少个spill是由参数io.sort.factor指定的默认为10个。但是当spill的数量非常大的时候，merge一次并行运行的spill仍然为10个,这样仍然会频繁的IO处理,因此适当的调大每次并行处理的spill数有利于减少merge数因此可以影响map的性能。

当map输出中间结果的时候也可以配置压缩。






